@page "/blog/blazor-auth-phan-3"


<PageTitle>My first test page 3</PageTitle>

<div class="content">
    <p>Sau khi ng∆∞·ªùi d√πng ƒëƒÉng nh·∫≠p th√†nh c√¥ng, b∆∞·ªõc ti·∫øp theo l√† x√°c ƒë·ªãnh h·ªç ƒë∆∞·ª£c ph√©p l√†m g√¨.
Ph·∫ßn n√†y s·∫Ω t·∫≠p trung v√†o hai n·ªôi dung quan tr·ªçng:</p>
<ul>
<li>Authorization trong Blazor bao g·ªìm Role-based, Policy-based v√† Resource-based Authorization.</li>
<li>C√°ch Blazor Web App g·ªçi c√°c API n·ªôi b·ªô v√† b√™n ngo√†i m·ªôt c√°ch an to√†n.</li>
</ul>
<h1 id="tong-quan-ve-authorization-trong-blazor">T·ªïng quan v·ªÅ Authorization trong Blazor</h1>
<p>Blazor s·ª≠ d·ª•ng c∆° ch·∫ø <strong>Authorization c·ªßa ASP.NET Core</strong>, d·ª±a tr√™n m√¥ h√¨nh <strong>Claims-based Identity</strong>.<br />
M·ªói ng∆∞·ªùi d√πng ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·ªüi m·ªôt <code>ClaimsPrincipal</code>, ch·ª©a c√°c <code>Claim</code> (nh∆∞ email, vai tr√≤, ho·∫∑c quy·ªÅn h·∫°n c·ª• th·ªÉ).</p>
<div class="alert alert-info" role="alert">
<div class="d-flex align-items-center">
<i class="bi-info-circle-fill flex-shrink-0 me-2"aria-label="Info:"></i>
<h5>Info:</h5>
</div>
<p>üí° ƒê·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ m√¥ h√¨nh Claims-based Identity trong .NET h√£y
ƒë·ªçc <a href="/post/authentication-va-authorization-trong-net">b√†i vi·∫øt n√†y</a></p>
</div>
<p>C√°c claim n√†y ƒë∆∞·ª£c l∆∞u trong <code>ClaimsPrincipal</code> v√† c√≥ th·ªÉ truy c·∫≠p th√¥ng
qua <code>AuthenticationStateProvider</code> nh∆∞ sau:</p>
<pre><code class="language-markup">&amp;#64;page &quot;/me&quot;
&amp;#64;inject AuthenticationStateProvider AuthStateProvider

&lt;h3&gt;Th√¥ng tin ng∆∞·ªùi d√πng&lt;/h3&gt;

&amp;#64;code {
    private string? userName;
    private string? email;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            userName = user.Identity.Name;
            email = user.FindFirst(c =&gt; c.Type == &quot;email&quot;)?.Value;
        }
    }
}
</code></pre>
<p>Ho·∫∑c c√≥ th·ªÉ inject tr·ª±c ti·∫øp qua Cascading Parameter:</p>
<pre><code class="language-markup">&amp;#64;attribute [Authorize]
&amp;#64;page &quot;/dashboard&quot;

&lt;CascadingAuthenticationState&gt;
    &lt;AuthorizeView&gt;
        &lt;Authorized&gt;
            &lt;h3&gt;Ch√†o &amp;#64;context.User.Identity?.Name!&lt;/h3&gt;
        &lt;/Authorized&gt;
        &lt;NotAuthorized&gt;
            &lt;p&gt;B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ xem trang n√†y.&lt;/p&gt;
        &lt;/NotAuthorized&gt;
    &lt;/AuthorizeView&gt;
&lt;/CascadingAuthenticationState&gt;
</code></pre>
<p>Nh·ªù m√¥ h√¨nh n√†y, m·ªçi component trong Blazor ƒë·ªÅu c√≥ th·ªÉ d·ªÖ d√†ng truy c·∫≠p th√¥ng tin ng∆∞·ªùi d√πng
ƒë·ªÉ hi·ªÉn th·ªã UI ph√π h·ª£p v√† ph√¢n quy·ªÅn.</p>
<h1 id="cac-co-che-authorization">C√°c c∆° ch·∫ø Authorization</h1>
<h2 id="role-based-authorization">Role-based Authorization</h2>
<p>Ph√¢n quy·ªÅn d·ª±a tr√™n <strong>Role</strong> l√† c√°ch ph·ªï bi·∫øn nh·∫•t, s·ª≠ d·ª•ng khi
Identity Provider (Azure AD, IdentityServer, Keycloak...) tr·∫£ v·ªÅ claim <code>role</code> ho·∫∑c <code>roles</code>.</p>
<p>S·ª≠ d·ª•ng <code>AuthorizeView</code>:</p>
<pre><code class="language-markup">&lt;AuthorizeView Roles=&quot;Administrator&quot;&gt;
    &lt;Authorized&gt;
        &lt;h3&gt;Khu v·ª±c qu·∫£n tr·ªã&lt;/h3&gt;
        &lt;p&gt;Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi th·∫•y ƒë∆∞·ª£c ph·∫ßn n√†y.&lt;/p&gt;
    &lt;/Authorized&gt;
    &lt;NotAuthorized&gt;
        &lt;p&gt;B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.&lt;/p&gt;
    &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;
</code></pre>
<p>Ho·∫∑c route ƒë∆∞·ª£c b·∫£o v·ªá b·∫±ng attribute:</p>
<pre><code class="language-razor">&amp;#64;page &quot;/admin&quot;

&amp;#64;attribute [Authorize(Roles = &quot;Administrator&quot;)]

&lt;h3&gt;Admin Dashboard&lt;/h3&gt;

&amp;#64;code {

}
</code></pre>
<h2 id="policy-based-authorization">Policy-based Authorization</h2>
<p>Policy-based cho ph√©p b·∫°n ƒë·ªãnh nghƒ©a quy t·∫Øc ph·ª©c t·∫°p h∆°n Role.</p>
<p>ƒê·ªãnh nghƒ©a Policy trong <code>Program.cs</code>:</p>
<pre><code class="language-csharp">builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy(&quot;RequireEmail&quot;, policy =&gt;
        policy.RequireClaim(&quot;email&quot;));
});
</code></pre>
<p>S·ª≠ d·ª•ng <code>AuthorizeView</code>:</p>
<pre><code class="language-markup">&lt;AuthorizeView Policy=&quot;RequireEmail&quot;&gt;
    &lt;Authorized&gt;
        &lt;p&gt;C·∫•u h√¨nh t√†i kho·∫£n&lt;/p&gt;
    &lt;/Authorized&gt;
    &lt;NotAuthorized&gt;
        &lt;p&gt;B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p n·ªôi dung n√†y.&lt;/p&gt;
    &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;
</code></pre>
<p>Ho·∫∑c route ƒë∆∞·ª£c b·∫£o v·ªá b·∫±ng attribute:</p>
<pre><code class="language-markup">&amp;#64;page &quot;/settings&quot;

&amp;#64;attribute [Authorize(Policy = &quot;RequireEmail&quot;)]

&lt;h3&gt;C·∫•u h√¨nh t√†i kho·∫£n&lt;/h3&gt;

&amp;#64;code {

}
</code></pre>
<h2 id="resource-based-authorization">Resource-based Authorization</h2>
<p>Resource-based cho ph√©p ki·ªÉm tra quy·ªÅn ƒë·ªông (dynamic), t√πy v√†o t·ª´ng ƒë·ªëi t∆∞·ª£ng c·ª• th·ªÉ.
V√≠ d·ª•: User ch·ªâ ƒë∆∞·ª£c s·ª≠a b√†i vi·∫øt c·ªßa ch√≠nh m√¨nh ho·∫∑c x√≥a t√†i nguy√™n m√† h·ªç s·ªü h·ªØu.</p>
<p>T·∫°o Handler Resource:</p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Authorization;

public class Document
{
    public string OwnerId { get; set; } = default!;
}

public class DocumentAuthorizationHandler : AuthorizationHandler&lt;OperationAuthorizationRequirement, Document&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        OperationAuthorizationRequirement requirement,
        Document resource)
    {
        if (requirement.Name == &quot;Edit&quot; &amp;&amp; 
            context.User.Identity?.Name == resource.OwnerId)
        {
            context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
}
</code></pre>
<p>ƒêƒÉng k√Ω handler trong <code>Program.cs</code>:</p>
<pre><code class="language-csharp">builder.Services.AddSingleton&lt;IAuthorizationHandler, DocumentAuthorizationHandler&gt;();
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy(&quot;CanEdit&quot;, policy =&gt;
        policy.AddRequirements(new OperationAuthorizationRequirement { Name = &quot;Edit&quot; }));
});
</code></pre>
<p>D√πng trong Component</p>
<pre><code class="language-markup">&amp;#64;page &quot;/document/{Id}&quot;
&amp;#64;inject IAuthorizationService AuthorizationService
&amp;#64;inject AuthenticationStateProvider AuthProvider

&amp;#64;if (canEdit)
{
    &lt;button&gt;S·ª≠a t√†i li·ªáu&lt;/button&gt;
}
else
{
    &lt;p&gt;B·∫°n kh√¥ng c√≥ quy·ªÅn ch·ªânh s·ª≠a t√†i li·ªáu n√†y.&lt;/p&gt;
}

&amp;#64;code {
    Document doc = new() { OwnerId = &quot;alice@example.com&quot; };

    bool canEdit = false;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var result = await AuthorizationService.AuthorizeAsync(user, doc, &quot;CanEdit&quot;);
        canEdit = result.Succeeded;
    }
}
</code></pre>
<div class="alert alert-info" role="alert">
<div class="d-flex align-items-center">
<i class="bi-info-circle-fill flex-shrink-0 me-2"aria-label="Info:"></i>
<h5>Info:</h5>
</div>
<p>Xem th√™m v·ªÅ Authorization trong .NET <a href="/post/authentication-va-authorization-trong-net">t·∫°i ƒë√¢y</a></p>
</div>
<h1 id="goi-protected-api">G·ªçi Protected API</h1>
<p>Trong Blazor Web App v·ªõi m√¥ h√¨nh BFF (Backend for Frontend),
·ª©ng d·ª•ng kh√¥ng gi·ªØ token ·ªü client m√† token n·∫±m ·ªü ph√≠a server. ƒêi·ªÅu n√†y c√≥ nghƒ©a l√†:</p>
<ul>
<li>Browser ch·ªâ gi·ªØ cookie x√°c th·ª±c.</li>
<li>Khi g·ªçi API, cookie ƒë√≥ s·∫Ω ƒë∆∞·ª£c g·ª≠i t·ª± ƒë·ªông ƒë·∫øn BFF.</li>
<li>BFF l·∫•y l·∫°i Access Token ƒë√£ ƒë∆∞·ª£c l∆∞u trong cookie (nh·ªù <code>SaveTokens = true</code>) v√† s·ª≠ d·ª•ng
token ƒë√≥ ƒë·ªÉ g·ªçi API backend.</li>
</ul>
<h2 id="internal-api">Internal API</h2>
<p>Internal API l√† c√°c endpoint ch·∫°y tr·ª±c ti·∫øp trong c√πng ·ª©ng d·ª•ng Blazor Server (BFF).
Ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p, n√™n cookie x√°c th·ª±c ƒë∆∞·ª£c g·ª≠i k√®m trong m·ªçi request.
Server ƒë·ªçc cookie, x√°c ƒë·ªãnh danh t√≠nh qua <code>HttpContext.User</code>.</p>
<p><strong>Lu·ªìng ho·∫°t ƒë·ªông:</strong></p>
<MermaidContainer >
<p>sequenceDiagram
participant User as Browser
participant BFF as Blazor Server
participant API as Internal API</p>
<p>User-&gt;&gt;BFF: GET /api/profile (cookie t·ª± ƒë·ªông g·ª≠i)
BFF-&gt;&gt;API: X·ª≠ l√Ω request, ƒë·ªçc HttpContext.User
API--&gt;&gt;BFF: D·ªØ li·ªáu ng∆∞·ªùi d√πng
BFF--&gt;&gt;User: JSON response</p>
</MermaidContainer>
<p>V√≠ d·ª•: API l·∫•y th√¥ng tin ng∆∞·ªùi d√πng</p>
<pre><code class="language-csharp">app.MapGet(&quot;/api/profile&quot;, (HttpContext ctx) =&gt;
{
    var user = ctx.User;
    if (user?.Identity?.IsAuthenticated != true)
        return Results.Unauthorized();

    return Results.Ok(new
    {
        Name = user.Identity!.Name,
        Email = user.FindFirst(ClaimTypes.Email)?.Value
    });
}).RequireAuthorization();
</code></pre>
<p>Client g·ªçi:</p>
<pre><code class="language-csharp">&amp;#64;inject HttpClient Http

&amp;#64;code {
    private object? profile;

    protected override async Task OnInitializedAsync()
    {
        // Cookie t·ª± ƒë·ªông g·ª≠i k√®m
        profile = await Http.GetFromJsonAsync&lt;object&gt;(&quot;api/profile&quot;);
    }
}
</code></pre>
<h2 id="external-api">External API</h2>
<p>Khi BFF c·∫ßn g·ªçi API b√™n ngo√†i thay m·∫∑t ng∆∞·ªùi d√πng (v√≠ d·ª• GitHub API),
ta kh√¥ng th·ªÉ d√πng cookie v√¨ cookie ch·ªâ c√≥ gi√° tr·ªã n·ªôi b·ªô.
Thay v√†o ƒë√≥, server s·∫Ω l·∫•y Access Token ƒë√£ l∆∞u khi ƒëƒÉng nh·∫≠p (OIDC) r·ªìi
ƒë√≠nh k√®m token v√†o header <code>Authorization: Bearer &lt;token&gt;</code>, r·ªìi proxy request ra ngo√†i.</p>
<p><strong>Lu·ªìng ho·∫°t ƒë·ªông:</strong></p>
<MermaidContainer >
<p>sequenceDiagram
participant User as Browser/Blazor Client
participant BFF as BFF Server
participant API as External API</p>
<p>User-&gt;&gt;BFF: G·ªçi /api/github-repos
BFF-&gt;&gt;BFF: L·∫•y access_token t·ª´ cookie (GetTokenAsync)
BFF-&gt;&gt;API: G·ª≠i request v·ªõi Authorization: Bearer token
API--&gt;&gt;BFF: Tr·∫£ d·ªØ li·ªáu JSON
BFF--&gt;&gt;User: JSON response</p>
</MermaidContainer>
<h3 id="tokenhandler">TokenHandler</h3>
<p>Ta t·∫°o m·ªôt <code>DelegatingHandler</code> ƒë·ªÉ t·ª± ƒë·ªông g·∫Øn Access Token cho c√°c request ra ngo√†i.</p>
<pre><code class="language-csharp">using System.Net.Http.Headers;
using Microsoft.AspNetCore.Authentication;

public class TokenHandler(IHttpContextAccessor httpContextAccessor) : 
    DelegatingHandler
{
    protected override async Task&lt;HttpResponseMessage&gt; SendAsync(
        HttpRequestMessage request, CancellationToken cancellationToken)
    {
        if (httpContextAccessor.HttpContext is null)
        {
            throw new Exception(&quot;HttpContext not available&quot;);
        }

        var accessToken = await httpContextAccessor.HttpContext.GetTokenAsync(&quot;access_token&quot;);

        if (accessToken is null)
        {
            throw new Exception(&quot;No access token&quot;);
        }

        request.Headers.Authorization =
            new AuthenticationHeaderValue(&quot;Bearer&quot;, accessToken);

        return await base.SendAsync(request, cancellationToken);
    }
}
</code></pre>
<h3 id="cau-hinh-trong-program.cs">C·∫•u h√¨nh trong Program.cs:</h3>
<pre><code class="language-csharp">builder.Services.AddHttpContextAccessor();
builder.Services.AddTransient&lt;TokenHandler&gt;();

builder.Services.AddHttpClient(&quot;ExternalApi&quot;, client =&gt;
{
    client.BaseAddress = new Uri(&quot;https://api.github.com/&quot;);
    client.DefaultRequestHeaders.UserAgent.ParseAdd(&quot;BlazorBFF&quot;);
}).AddHttpMessageHandler&lt;TokenHandler&gt;();
</code></pre>
<div class="alert alert-info" role="alert">
<div class="d-flex align-items-center">
<i class="bi-info-circle-fill flex-shrink-0 me-2"aria-label="Info:"></i>
<h5>Info:</h5>
</div>
<p>Khi g·ªçi ExternalApi, .NET s·∫Ω t·ª± ƒë·ªông th√™m Access Token t·ª´ <code>HttpContext</code>.</p>
</div>
<h3 id="endpoint-proxy-server">Endpoint proxy server</h3>
<pre><code class="language-csharp">app.MapGet(&quot;/api/github-repos&quot;, async (IHttpClientFactory factory) =&gt;
{
    var client = factory.CreateClient(&quot;ExternalApi&quot;);
    var repos = await client.GetFromJsonAsync&lt;List&lt;GithubRepo&gt;&gt;(&quot;user/repos&quot;);
    return Results.Ok(repos);
}).RequireAuthorization();
</code></pre>
<h3 id="client-se-goi-toi-server-endpoint">Client s·∫Ω g·ªçi t·ªõi server endpoint</h3>
<pre><code class="language-markup">&amp;#64;inject HttpClient Http

&amp;#64;code {
    private List&lt;GithubRepo&gt;? repos;

    protected override async Task OnInitializedAsync()
    {
        repos = await Http.GetFromJsonAsync&lt;List&lt;GithubRepo&gt;&gt;(&quot;api/github-repos&quot;);
    }
}
</code></pre>
<h1 id="ket-luan">K·∫øt lu·∫≠n</h1>
<p>Trong ph·∫ßn n√†y, ch√∫ng ta ƒë√£ t√¨m hi·ªÉu chi ti·∫øt v·ªÅ Authorization trong Blazor, bao g·ªìm c√°c c∆° ch·∫ø<br />
Role-based, Policy-based cho ƒë·∫øn Resource-based Authorization, gi√∫p ki·ªÉm so√°t quy·ªÅn truy
c·∫≠p c·ªßa ng∆∞·ªùi d√πng m·ªôt c√°ch linh ho·∫°t. B√™n c·∫°nh ƒë√≥, b·∫°n c≈©ng ƒë√£ n·∫Øm ƒë∆∞·ª£c c√°ch Blazor Web App
g·ªçi Internal API v√† External API m·ªôt c√°ch an to√†n s·ª≠ d·ª•ng Cookie Authentication v√†
Access Token ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n server.</p>
<p>·ªû <a href="/post/authentication-va-authorization-trong-blazor-phan-4-authentication-voi-nhieu-identity-provider">ph·∫ßn ti·∫øp theo</a>, ch√∫ng ta s·∫Ω x√¢y d·ª±ng m·ªôt c∆° ch·∫ø ƒëƒÉng nh·∫≠p linh ho·∫°t h∆°n cho ph√©p ng∆∞·ªùi d√πng
s·ª≠ d·ª•ng nhi·ªÅu Identity Provider (IdP) nh∆∞ Google, Facebook ho·∫∑c Microsoft Entra ID
nh∆∞ng v·∫´n ƒë∆∞·ª£c √°nh x·∫° v·ªÅ m·ªôt t√†i kho·∫£n duy nh·∫•t trong ·ª©ng d·ª•ng. ƒêi·ªÅu n√†y s·∫Ω gi√∫p h·ªá th·ªëng
h·ªó tr·ª£ ƒëƒÉng nh·∫≠p ƒëa k√™nh m√† v·∫´n duy tr√¨ t√≠nh th·ªëng nh·∫•t v√† b·∫£o m·∫≠t trong qu·∫£n l√Ω danh t√≠nh.</p>

</div>
