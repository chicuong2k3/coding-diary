<!DOCTYPE html><html lang="en"><head>
  <base href="/coding-diary/" />
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Code Magic</title>
    
    <link href="_framework/dotnet.tbd77kjr03.js" rel="preload" as="script" fetchpriority="high" crossorigin="anonymous" integrity="sha256-x5l3PT6D6JX8Rd5vPXm9Of4It1lTCUvqWtBzrronCI0="/>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="lib/bootstrap/dist/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="css/app.css"/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <link href="DocumentationWeb.styles.css" rel="stylesheet"/>
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
    <script type="importmap">{
  "imports": {
    "./_framework/blazor.webassembly.js": "./_framework/blazor.webassembly.66stpp682q.js",
    "./_framework/dotnet.native.js": "./_framework/dotnet.native.wrr3s1u3jw.js",
    "./_framework/dotnet.runtime.js": "./_framework/dotnet.runtime.2tx45g8lli.js",
    "./_framework/dotnet.js": "./_framework/dotnet.tbd77kjr03.js"
  },
  "scopes": {},
  "integrity": {
    "./_framework/blazor.webassembly.66stpp682q.js": "sha256-3lCWrko3zwspV40aQhs2S/IMkRSarnHRKIdkHhuXIBA=",
    "./_framework/blazor.webassembly.js": "sha256-3lCWrko3zwspV40aQhs2S/IMkRSarnHRKIdkHhuXIBA=",
    "./_framework/dotnet.js": "sha256-x5l3PT6D6JX8Rd5vPXm9Of4It1lTCUvqWtBzrronCI0=",
    "./_framework/dotnet.native.js": "sha256-pHATP1UYfVbgkubj/zSgOMTH5p50o8sWVxiheNxMVnA=",
    "./_framework/dotnet.native.wrr3s1u3jw.js": "sha256-pHATP1UYfVbgkubj/zSgOMTH5p50o8sWVxiheNxMVnA=",
    "./_framework/dotnet.runtime.2tx45g8lli.js": "sha256-2lZh9yO0fnzm3Xt7yV+Kox3DH3nK7L8hDhm84VT1xco=",
    "./_framework/dotnet.runtime.js": "sha256-2lZh9yO0fnzm3Xt7yV+Kox3DH3nK7L8hDhm84VT1xco=",
    "./_framework/dotnet.tbd77kjr03.js": "sha256-x5l3PT6D6JX8Rd5vPXm9Of4It1lTCUvqWtBzrronCI0="
  }
}</script>

<!-- %%-PRERENDERING-HEADOUTLET-BEGIN-%% -->
<title>Chương 2: Đại số tuyến tính (Linear algebra)</title>
<!-- %%-PRERENDERING-HEADOUTLET-END-%% -->
</head>

<body>
    <div id="app">
<!-- %%-PRERENDERING-BEGIN-%% -->
<div class="site-content" b-qjr5eoji3o><header class="sakura-header" b-qjr5eoji3o><div class="sakura-header-inner" b-qjr5eoji3o><div class="brand-wrap" b-qjr5eoji3o><a class="brand" href b-qjr5eoji3o>Code Magic</a></div>

            <nav class="main-nav" aria-label="Primary" b-qjr5eoji3o><ul b-qjr5eoji3o><li b-qjr5eoji3o><a href b-qjr5eoji3o>Trang chủ</a></li>
                    <li b-qjr5eoji3o><a href="book" b-qjr5eoji3o>Thư viện sách</a></li>
                    <li b-qjr5eoji3o><a href="bookmarks" b-qjr5eoji3o>Đánh dấu</a></li>
                    <li b-qjr5eoji3o><a href="about" b-qjr5eoji3o>Giới thiệu</a></li></ul></nav>

            <div class="header-actions" b-qjr5eoji3o><div class="icon-row" b-qjr5eoji3o><button class="icon btn-ghost" title="Toggle theme" b-qjr5eoji3o><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" b-qjr5eoji3o><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" b-qjr5eoji3o></path></svg></button>
                    <a class="icon btn-ghost" href="https://github.com/chicuong2k3" target="_blank" title="GitHub" b-qjr5eoji3o><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" b-qjr5eoji3o><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" b-qjr5eoji3o></path></svg></a>
                    <button class="icon btn-ghost search-btn" title="Search" b-qjr5eoji3o><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" b-qjr5eoji3o><circle cx="11" cy="11" r="8" b-qjr5eoji3o></circle>
                            <path d="m21 21-4.35-4.35" b-qjr5eoji3o></path></svg></button></div></div></div></header><div class="page sakura-page  " b-qjr5eoji3o><aside class="left-sidebar" b-qjr5eoji3o><div class="sidebar-tags" b-qjr5eoji3o><div class="book-chapters-container" b-nsp51uw5bw><h3 class="book-chapters-title" b-nsp51uw5bw><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" b-nsp51uw5bw><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20" b-nsp51uw5bw></path>
                <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z" b-nsp51uw5bw></path></svg>
            MATHEMATICS FOR MACHINE LEARNING</h3>
        <a href="book/mathematics-for-machine-learning" class="view-all-link" b-nsp51uw5bw>Xem tất cả chương →</a>
        <div class="chapters-list" b-nsp51uw5bw><a href="mathematics-for-machine-learning/forward" class="chapter-item " b-nsp51uw5bw><span class="chapter-num" b-nsp51uw5bw>1</span>
                    <span class="chapter-name" title="L&#x1EDD;i t&#x1EF1;a" b-nsp51uw5bw>L&#x1EDD;i t&#x1EF1;a</span></a><a href="mathematics-for-machine-learning/chapter-1" class="chapter-item " b-nsp51uw5bw><span class="chapter-num" b-nsp51uw5bw>2</span>
                    <span class="chapter-name" title="Ch&#x1B0;&#x1A1;ng 1: Gi&#x1EDB;i thi&#x1EC7;u" b-nsp51uw5bw>Ch&#x1B0;&#x1A1;ng 1: Gi&#x1EDB;i thi&#x1EC7;u</span></a><a href="mathematics-for-machine-learning/chapter-2" class="chapter-item active" b-nsp51uw5bw><span class="chapter-num" b-nsp51uw5bw>3</span>
                    <span class="chapter-name" title="Ch&#x1B0;&#x1A1;ng 2: &#x110;&#x1EA1;i s&#x1ED1; tuy&#x1EBF;n t&#xED;nh (Linear algebra)" b-nsp51uw5bw>Ch&#x1B0;&#x1A1;ng 2: &#x110;&#x1EA1;i s&#x1ED1; tuy&#x1EBF;n t&#xED;nh (Linear...</span></a></div><div class="bookmark-list-container" b-mtxm6u0zg7><div class="bookmark-header" b-mtxm6u0zg7><h3 class="bookmark-title" b-mtxm6u0zg7><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" b-mtxm6u0zg7><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" b-mtxm6u0zg7></path></svg>
            Đánh dấu
        </h3>
        <a href="bookmarks" class="view-all-bookmarks" title="Xem tất cả" b-mtxm6u0zg7><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" b-mtxm6u0zg7><polyline points="9 18 15 12 9 6" b-mtxm6u0zg7></polyline></svg></a></div><p class="no-bookmarks" b-mtxm6u0zg7>Chưa có đánh dấu nào</p></div></div></div></aside><main class="doc-main" b-qjr5eoji3o><article class="content" b-qjr5eoji3o>

<div class="content"><div class="latex-container"></div>
<p>Khi hình thức hóa các khái niệm trực quan, một cách tiếp cận phổ biến là xác định một tập hợp các đối tượng cùng với các quy tắc thao tác trên chúng - đó là ý nghĩa của đại số. <strong>Đại số tuyến tính</strong> (Linear algebra) nghiên cứu các <strong>vectơ</strong> (vector) và các quy tắc để cộng, nhân vô hướng và thao tác với chúng.</p>
<p>Trong chương này, chúng ta sử dụng ký hiệu in đậm cho <strong>vectơ</strong>, ví dụ <span class="math">\(\mathbf{x}\)</span>, <span class="math">\(\mathbf{y}\)</span> (thay vì <span class="math">\(\vec{x}\)</span>, <span class="math">\(\vec{y}\)</span>). Một <strong>vectơ</strong> là một đối tượng mà ta có thể cộng với <strong>vectơ</strong> khác và nhân với một số vô hướng, kết quả thu được vẫn là một <strong>vectơ</strong>. Từ góc nhìn trừu tượng, mọi đối tượng thỏa hai tính chất này (đối tượng nhân với vô hướng hoặc cộng với đối tượng cùng loại đều cho ra đối tượng cùng loại) đều được coi là <strong>vectơ</strong>. Dưới đây là một vài ví dụ quen thuộc:</p>
<ul><li><strong>Vectơ</strong> hình học: Ví dụ về vectơ này có lẽ đã quen thuộc từ toán học và vật lý ở bậc phổ thông.  Vectơ hình học là các đoạn thẳng có hướng, có thể được vẽ (ít nhất là trong không gian hai chiều). Hai vectơ hình học <span class="math">\(\vec{x}\)</span>, <span class="math">\(\vec{y}\)</span> có thể được cộng lại sao cho:</li></ul>
<div class="math">
\[
\vec{x} + \vec{y} = \vec{z}
\]</div>
<p>trong đó <span class="math">\(\vec{z}\)</span> là một vectơ hình học khác.<br>
Hơn nữa, phép nhân một vectơ với một số vô hướng <span class="math">\(\lambda \in \mathbb{R}\)</span>, tức <span class="math">\(\lambda \vec{x}\)</span>, cũng tạo ra một vectơ hình học. Trên thực tế, đó là vectơ ban đầu được co giãn theo hệ số <span class="math">\(\lambda\)</span>.</p>
<p>Vì vậy, vectơ hình học là những ví dụ cụ thể của khái niệm vectơ đã được giới thiệu trước đó. Việc diễn giải vectơ dưới dạng vectơ hình học cho phép chúng ta sử dụng trực giác về <strong>hướng</strong> và <strong>độ lớn</strong> để suy luận về các phép toán toán học.</p>
<ul><li>Đa thức: Đa thức cũng là vectơ. Hai đa thức có thể được cộng với nhau và kết quả là một đa thức khác; chúng cũng có thể được nhân với một số vô hướng <span class="math">\(\lambda \in \mathbb{R}\)</span>, và kết quả vẫn là một đa thức. Do đó, đa thức là những vectơ.
Lưu ý rằng đa thức rất khác với vectơ hình học. Trong khi vectơ hình học là các &quot;hình vẽ&quot; cụ thể, thì đa thức là các khái niệm trừu tượng. Tuy nhiên, cả hai đều là vectơ theo nghĩa đã mô tả trước đó.</li>
<li>Tín hiệu âm thanh: Tín hiệu âm thanh được biểu diễn dưới dạng một chuỗi các số. Ta có thể cộng các tín hiệu âm thanh lại với nhau, và tổng của chúng là một tín hiệu âm thanh mới. Nếu ta co giãn (nhân vô hướng) một tín hiệu âm thanh, ta cũng thu được một tín hiệu âm thanh khác. Vì vậy, tín hiệu âm thanh cũng là một loại vectơ.</li>
<li>Các phần tử của <span class="math">\(\mathbb{R}^n\)</span> là vectơ: Các phần tử của <span class="math">\(\mathbb{R}^n\)</span> (bộ gồm <span class="math">\(n\)</span> số thực) là vectơ. <span class="math">\(\mathbb{R}^n\)</span> trừu tượng hơn đa thức, và đây là khái niệm mà cuốn sách này tập trung vào. Ví dụ,</li></ul>
<div class="math">
\[
\mathbf{a} =
\begin{bmatrix}
1 \\
2 \\
3
\end{bmatrix}
\in \mathbb{R}^3
\]</div>
<p>là một bộ ba số. Khi cộng hai vectơ <span class="math">\(\mathbf{a}, \mathbf{b} \in \mathbb{R}^n\)</span> theo từng thành phần, ta thu được một vectơ khác <span class="math">\(\mathbf{c} \in \mathbb{R}^n\)</span>. Tương tự, khi nhân <span class="math">\(\mathbf{a} \in \mathbb{R}^n\)</span> với một số vô hướng <span class="math">\(\lambda \in \mathbb{R}\)</span>, ta thu được vectơ đã được co giãn <span class="math">\(\lambda \mathbf{a} \in \mathbb{R}^n\)</span>.</p>
<p>Việc xem vectơ như các phần tử của <span class="math">\(\mathbb{R}^n\)</span> còn có một lợi ích khác: nó tương ứng khá tự nhiên với các mảng số thực trên máy tính. Nhiều ngôn ngữ lập trình hỗ trợ các phép toán trên mảng, cho phép triển khai thuận tiện các thuật toán liên quan đến phép toán vectơ. Tuy nhiên, cần cẩn thận kiểm tra xem các phép toán trên mảng đó có thực sự tương ứng với các phép toán vectơ hay không khi cài đặt trên máy tính.</p>
<p>Đại số tuyến tính tập trung vào những điểm tương đồng giữa các khái niệm vectơ này: ta có thể cộng chúng và nhân chúng với các số vô hướng. Trong cuốn sách này, chúng tôi chủ yếu tập trung vào các vectơ trong <span class="math">\(\mathbb{R}^n\)</span>, vì hầu hết các thuật toán trong đại số tuyến tính đều được xây dựng trong <span class="math">\(\mathbb{R}^n\)</span>.</p>
<p>Ở Chương 8, ta sẽ thấy rằng dữ liệu thường được biểu diễn dưới dạng các vectơ trong <span class="math">\(\mathbb{R}^n\)</span>. Trong sách này, chúng tôi tập trung vào các không gian vectơ hữu hạn chiều (finite-dimensional vector spaces); trong trường hợp đó, tồn tại một sự tương ứng 1:1 giữa bất kỳ loại vectơ nào và <span class="math">\(\mathbb{R}^n\)</span>. Khi thuận tiện, chúng tôi sẽ sử dụng trực giác về vectơ hình học và xem xét các thuật toán dựa trên mảng.
vector
Một khái niệm quan trọng là <strong>tính đóng</strong> (closure) của một tập: bắt đầu từ một tập <strong>vectơ đơn vị</strong> (unit vector) và thực hiện các phép cộng/tỉ lệ, tập các vectơ (set of vectors) có thể sinh ra là gì? Câu trả lời dẫn đến khái niệm không gian <strong>vectơ</strong> (vector space). Không gian <strong>vectơ</strong> và các tính chất của nó là nền tảng cho nhiều phép toán trong máy học.</p>
<p>Phần còn lại của chương bày các khái niệm cơ bản: <strong>hệ phương trình tuyến tính</strong> (system of linear equations), <strong>ma trận</strong> (matrix) và các phép toán trên <strong>ma trận</strong>, <strong>không gian nghiệm</strong> (solution space), <strong>cơ sở</strong> (basis) và các phép biến đổi cần thiết cho các ứng dụng máy học.</p>
<p><figure><img src="/coding-diary/images/Mathematics-for-Machine-Learning/_page_19_Figure_1.png" alt="Hình 2.2: Sơ đồ tư duy (mind map) về các khái niệm được giới thiệu trong chương này, cùng với vị trí mà chúng được sử dụng ở các phần khác của cuốn sách." style="max-width:100%;height:auto;"><figcaption style="margin-left:auto;margin-right:auto;font-style:italic;text-align:center;">Hình 2.2: Sơ đồ tư duy (mind map) về các khái niệm được giới thiệu trong chương này, cùng với vị trí mà chúng được sử dụng ở các phần khác của cuốn sách.</figcaption></figure></p>
<h2 id="he-phuong-trinh-tuyen-tinh-system-of-linear-equations">2.1 Hệ phương trình tuyến tính (system of linear equations)</h2>
<p><strong>Hệ phương trình tuyến tính</strong> (system of linear equations) là trung tâm của <strong>đại số tuyến tính</strong>. Nhiều bài toán thực tế có thể được mô tả dưới dạng <strong>hệ phương trình tuyến tính</strong>, và <strong>đại số tuyến tính</strong> cung cấp công cụ để phân tích và giải các hệ này.</p>
<p><strong>Ví dụ 2.1 (Bài toán phân phối tài nguyên).</strong></p>
<p>Giả sử một công ty sản xuất n sản phẩm <span class="math">\(N^1, ..., N^n\)</span> bằng cách sử dụng m loại tài nguyên <span class="math">\(R^1, ..., R^m\)</span>. Để sản xuất một đơn vị sản phẩm <span class="math">\(N^j\)</span> cần <span class="math">\(a_{ij}\)</span> đơn vị tài nguyên <span class="math">\(R^i\)</span> <span class="math">\((i = 1,...,m; j = 1,...,n)\)</span>. Nếu có <span class="math">\(b^i\)</span> đơn vị tài nguyên <span class="math">\(R^i\)</span> sẵn có, ta muốn tìm số lượng <span class="math">\(x_1,...,x_n\)</span> sản phẩm để sử dụng tối ưu tài nguyên, lý tưởng là không dư thừa.</p>
<p>Việc tiêu thụ tài nguyên <span class="math">\(R^i\)</span> bởi kế hoạch sản xuất <span class="math">\(x_1,...,x_n\)</span> là:</p>
<div class="math">
\[
a_{i1}x_1 + \cdots + a_{in}x_n \tag{2.2}
\]</div>
<p>Do đó, một kế hoạch sản xuất tối ưu <span class="math">\((x_1, \ldots, x_n) \in \mathbb{R}^n\)</span> phải thỏa mãn hệ phương trình sau:</p>
<div class="math">
\[
\begin{aligned}
a_{11}x_1 + \cdots + a_{1n}x_n &amp;= b_1 \\
\vdots \qquad\qquad\qquad\quad &amp; \vdots \\
a_{m1}x_1 + \cdots + a_{mn}x_n &amp;= b_m
\end{aligned}
\]</div>
<p>Ta gọi đây là dạng tổng quát (general form) của <strong>hệ phương trình tuyến tính</strong>; <strong>nghiệm</strong> (solution) của hệ là các n-tuple (<span class="math">\(x_1\)</span>,...,<span class="math">\(x_n\)</span>) thỏa các phương trình trên.</p>
<p><strong>Ví dụ 2.2.</strong> Xét hệ</p>
<div class="math">
\[
\begin{aligned}
x_1 + x_2 + x_3 &amp;= 3 \quad (1) \\
x_1 - x_2 + 2x_3 &amp;= 2 \quad (2) \\
2x_1 + 3x_3 &amp;= 1 \quad (3)
\end{aligned}
\tag{2.4}
\]</div>
<p><strong>không có nghiệm</strong>: Cộng hai phương trình đầu tiên ta được<br>
<span class="math">\(2x_1 + 3x_3 = 5\)</span>, điều này mâu thuẫn với phương trình thứ ba (3).</p>
<hr>
<p>Xét hệ phương trình tuyến tính</p>
<div class="math">
\[
\begin{aligned}
x_1 + x_2 + x_3 &amp;= 3 \quad (1) \\
x_1 - x_2 + 2x_3 &amp;= 2 \quad (2) \\
x_2 + x_3 &amp;= 2 \quad (3)
\end{aligned}
\tag{2.5}
\]</div>
<p>Từ phương trình (1) và (3) suy ra <span class="math">\(x_1 = 1\)</span>.<br>
Từ (1) + (2) ta được <span class="math">\(2x_1 + 3x_3 = 5\)</span>, suy ra <span class="math">\(x_3 = 1\)</span>.<br>
Từ (3) tiếp theo ta có <span class="math">\(x_2 = 1\)</span>.</p>
<p>Do đó, <span class="math">\((1, 1, 1)\)</span> là nghiệm duy nhất và cũng là nghiệm duy nhất có thể của hệ (có thể kiểm tra lại bằng cách thay <span class="math">\((1, 1, 1)\)</span> vào hệ phương trình).</p>
<hr>
<p>Xét ví dụ thứ ba:</p>
<div class="math">
\[
\begin{aligned}
x_1 + x_2 + x_3 &amp;= 3 \quad (1) \\
x_1 - x_2 + 2x_3 &amp;= 2 \quad (2) \\
2x_1 + 3x_3 &amp;= 5 \quad (3)
\end{aligned}
\tag{2.6}
\]</div>
<p>Vì <span class="math">\((1) + (2) = (3)\)</span>, nên phương trình thứ ba là <strong>dư thừa</strong> và có thể loại bỏ.<br>
Từ (1) và (2) ta thu được</p>
<div class="math">
\[
2x_1 = 5 - 3x_3, \qquad 2x_2 = 1 + x_3.
\]</div>
<p>Đặt <span class="math">\(x_3 = a \in \mathbb{R}\)</span> là một <strong>biến tự do</strong>, khi đó mọi bộ ba</p>
<div class="math">
\[
\left(
\frac{5}{2} - \frac{3}{2}a,\;
\frac{1}{2} + \frac{1}{2}a,\;
a
\right),
\quad a \in \mathbb{R}
\]</div>
<p>đều là nghiệm của hệ phương trình.</p>
<p>Nói chung, đối với một hệ phương trình tuyến tính với các hệ số thực, ta sẽ thu được <strong>hoặc không có nghiệm</strong>, <strong>hoặc đúng một nghiệm</strong>, <strong>hoặc vô số nghiệm</strong>.<br>
Hồi quy tuyến tính (Chương 9) giải quyết một biến thể của Ví dụ 2.1 trong trường hợp ta <strong>không thể giải trực tiếp</strong> hệ phương trình tuyến tính.</p>
<hr>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p><strong>Diễn giải hình học của các hệ phương trình tuyến tính</strong></p>
<p>Trong một hệ phương trình tuyến tính với hai biến <span class="math">\(x_1, x_2\)</span>, mỗi phương trình tuyến tính xác định một <strong>đường thẳng</strong> trên mặt phẳng <span class="math">\(x_1x_2\)</span>. Vì nghiệm của hệ phương trình phải thỏa mãn <strong>tất cả</strong> các phương trình đồng thời, nên <strong>tập nghiệm</strong> chính là <strong>giao</strong> của các đường thẳng này.</p>
<p>Tập giao đó có thể là:</p>
<ul><li>một <strong>đường thẳng</strong> (nếu các phương trình mô tả cùng một đường),</li>
<li>một <strong>điểm</strong>,</li>
<li>hoặc <strong>rỗng</strong> (khi các đường thẳng song song).</li></ul>
<p>Một minh họa được cho trong Hình 2.3 với hệ phương trình</p>
<div class="math">
\[
\begin{aligned}
4x_1 + 4x_2 &amp;= 5 \\
2x_1 - 4x_2 &amp;= 1
\end{aligned}
\tag{2.8}
\]</div>
<p>trong đó không gian nghiệm là điểm <span class="math">\((x_1, x_2) = \left(1, \frac{1}{4}\right)\)</span>.</p>
<p><figure><img src="/coding-diary/images/Mathematics-for-Machine-Learning/_page_21_Figure_1.png" alt="Hình 2.3: Không gian nghiệm của một hệ gồm hai phương trình tuyến tính với hai biến có thể được diễn giải theo hình học như giao điểm của hai đường thẳng. Mỗi phương trình tuyến tính tương ứng với một đường thẳng." style="max-width:100%;height:auto;"><figcaption style="margin-left:auto;margin-right:auto;font-style:italic;text-align:center;">Hình 2.3: Không gian nghiệm của một hệ gồm hai phương trình tuyến tính với hai biến có thể được diễn giải theo hình học như giao điểm của hai đường thẳng. Mỗi phương trình tuyến tính tương ứng với một đường thẳng.</figcaption></figure></p>
<p>Tương tự, với <strong>ba biến</strong>, mỗi phương trình tuyến tính xác định một <strong>mặt phẳng</strong> trong không gian ba chiều. Khi lấy giao của các mặt phẳng này, tức là thỏa mãn tất cả các phương trình cùng lúc, ta có thể thu được một tập nghiệm là:</p>
<ul><li>một <strong>mặt phẳng</strong>,</li>
<li>một <strong>đường thẳng</strong>,</li>
<li>một <strong>điểm</strong>,</li>
<li>hoặc <strong>rỗng</strong> (khi các mặt phẳng không có giao chung).</li></ul></div>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p><strong>Dạng ma trận của hệ phương trình tuyến tính</strong></p>
<p>Để tiếp cận việc giải các hệ phương trình tuyến tính một cách có hệ thống, ta sẽ giới thiệu một ký hiệu gọn gàng và hữu ích. Ta gom các hệ số <span class="math">\(a_{ij}\)</span> thành các vectơ, rồi gom các vectơ đó thành <strong>ma trận</strong>. Nói cách khác, ta viết hệ phương trình trong (2.3) dưới dạng:</p>
<div class="math">
\[
\begin{bmatrix}
a_{11} \\
\vdots \\
a_{m1}
\end{bmatrix} x_1
+
\begin{bmatrix}
a_{12} \\
\vdots \\
a_{m2}
\end{bmatrix} x_2
+ \cdots +
\begin{bmatrix}
a_{1n} \\
\vdots \\
a_{mn}
\end{bmatrix} x_n
=
\begin{bmatrix}
b_1 \\
\vdots \\
b_m
\end{bmatrix}
\tag{2.9}
\]</div>
<p>Tương đương với</p>
<div class="math">
\[
\begin{bmatrix}
a_{11} &amp; \cdots &amp; a_{1n} \\
\vdots &amp; \ddots &amp; \vdots \\
a_{m1} &amp; \cdots &amp; a_{mn}
\end{bmatrix}
\begin{bmatrix}
x_1 \\
\vdots \\
x_n
\end{bmatrix}
=
\begin{bmatrix}
b_1 \\
\vdots \\
b_m
\end{bmatrix}
\tag{2.10}
\]</div>
<p>Trong phần tiếp theo, chúng ta sẽ xem xét kỹ hơn các ma trận này và định nghĩa các quy tắc tính toán. Chúng ta sẽ quay lại việc giải các hệ phương trình tuyến tính ở Mục 2.3.</p></div>
<h2 id="ma-tran">2.2 Ma trận</h2>
<p><strong>Ma trận</strong> (matrix) là cách gọn để biểu diễn hệ tuyến tính và các ánh xạ tuyến tính (linear mappings) (hàm tuyến tính).</p>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p><strong>Định nghĩa 2.1 Ma trận</strong></p>
<p>Với m,n <span class="math">\(\in\)</span> <span class="math">\(\mathbb{N}\)</span>, một <strong>ma trận</strong> thực kích thước <span class="math">\(m \times n\)</span> là một bảng số <span class="math">\(a_{ij}\)</span> sắp xếp thành m hàng và n cột:</p>
<div class="math">
\[
A =
\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix},
\qquad a_{ij} \in \mathbb{R}.
\]</div></div>
<p><span class="math">\(\mathbb{R}^{m \times n}\)</span> là tập hợp tất cả các ma trận kích thước <span class="math">\((m, n)\)</span> với giá trị thực.<br>
Một ma trận <span class="math">\(A \in \mathbb{R}^{m \times n}\)</span> cũng có thể được biểu diễn tương đương như một vectơ <span class="math">\(a \in \mathbb{R}^{mn}\)</span> bằng cách <strong>xếp chồng tất cả <span class="math">\(n\)</span> cột của ma trận lại thành một vectơ dài</strong>.</p>
<p>Theo quy ước, <strong>ma trận</strong> kích thước <span class="math">\(1 \times n\)</span> được gọi là <strong>vectơ</strong> hàng, còn <strong>ma trận</strong>  <span class="math">\(m \times 1\)</span> được gọi là <strong>vectơ</strong> cột.</p>
<h3 id="cong-va-nhan-ma-tran">2.2.1 Cộng và nhân ma trận</h3>
<p>Tổng của hai ma trận <span class="math">\(A \in \mathbb{R}^{m \times n}\)</span>, <span class="math">\(B \in \mathbb{R}^{m \times n}\)</span> được định nghĩa là phép cộng <strong>theo từng phần tử</strong>, tức là</p>
<div class="math">
\[
A + B :=
\begin{bmatrix}
a_{11} + b_{11} &amp; \cdots &amp; a_{1n} + b_{1n} \\
\vdots &amp; \ddots &amp; \vdots \\
a_{m1} + b_{m1} &amp; \cdots &amp; a_{mn} + b_{mn}
\end{bmatrix}
\in \mathbb{R}^{m \times n}.
\tag{2.12}
\]</div>
<p>Với các ma trận <span class="math">\(A \in \mathbb{R}^{m \times n}\)</span>, <span class="math">\(B \in \mathbb{R}^{n \times k}\)</span>, các phần tử <span class="math">\(c_{ij}\)</span> của tích ma trận <span class="math">\(C = AB \in \mathbb{R}^{m \times k}\)</span> được tính bởi</p>
<div class="math">
\[
c_{ij} = \sum_{l=1}^{n} a_{il} b_{lj}, \qquad i = 1,\ldots,m,\; j = 1,\ldots,k.
\tag{2.13}
\]</div>
<p>Điều này có nghĩa là để tính phần tử <span class="math">\(c_{ij}\)</span>, ta nhân các phần tử của <strong>hàng thứ <span class="math">\(i\)</span> của <span class="math">\(A\)</span></strong> với <strong>cột thứ <span class="math">\(j\)</span> của <span class="math">\(B\)</span></strong> rồi cộng chúng lại. Sau này, trong Mục 3.2, ta sẽ gọi phép toán này là <strong>tích vô hướng</strong> của hàng và cột tương ứng. Trong những trường hợp cần nhấn mạnh rằng ta đang thực hiện phép nhân, ta dùng ký hiệu <span class="math">\(A \cdot B\)</span> để chỉ phép nhân.</p>
<p><strong>Nhận xét.</strong> Ma trận chỉ có thể nhân được nếu các kích thước &quot;kề nhau&quot; phù hợp. Ví dụ, một ma trận <span class="math">\(n \times k\)</span> có thể nhân với một ma trận <span class="math">\(k \times m\)</span> (từ bên trái):</p>
<div class="math">
\[
\underbrace{A}_{n \times k} \;
\underbrace{B}_{k \times m}
=
\underbrace{C}_{n \times m}.
\tag{2.14}
\]</div>
<p>Tích <span class="math">\(BA\)</span> không được xác định nếu <span class="math">\(m \ne n\)</span> vì các kích thước kề nhau không khớp.</p>
<p><strong>Nhận xét.</strong> Phép nhân ma trận <strong>không</strong> được định nghĩa theo kiểu nhân từng phần tử, tức là nhìn chung
<span class="math">\(c_{ij} \ne a_{ij} b_{ij}\)</span> (kể cả khi kích thước của <span class="math">\(A, B\)</span> phù hợp). Kiểu nhân theo từng phần tử này thường xuất hiện trong các ngôn ngữ lập trình khi nhân các mảng (đa chiều) với nhau và được gọi là <strong>tích Hadamard</strong>.</p>
<p><strong>Ví dụ 2.3</strong></p>
<p>Với</p>
<div class="math">
\[
A =
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
3 &amp; 2 &amp; 1
\end{bmatrix}
\in \mathbb{R}^{2 \times 3},
\qquad
B =
\begin{bmatrix}
0 &amp; 2 \\
1 &amp; -1 \\
0 &amp; 1
\end{bmatrix}
\in \mathbb{R}^{3 \times 2},
\]</div>
<p>ta thu được</p>
<div class="math">
\[
AB =
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
3 &amp; 2 &amp; 1
\end{bmatrix}
\begin{bmatrix}
0 &amp; 2 \\
1 &amp; -1 \\
0 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
2 &amp; 3 \\
2 &amp; 5
\end{bmatrix}
\in \mathbb{R}^{2 \times 2},
\tag{2.15}
\]</div>
<p>và</p>
<div class="math">
\[
BA =
\begin{bmatrix}
0 &amp; 2 \\
1 &amp; -1 \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
3 &amp; 2 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
6 &amp; 4 &amp; 2 \\
-2 &amp; 0 &amp; 2 \\
3 &amp; 2 &amp; 1
\end{bmatrix}
\in \mathbb{R}^{3 \times 3}.
\tag{2.16}
\]</div>
<p>Từ ví dụ này, ta thấy phép nhân ma trận <strong>không giao hoán</strong>, tức là <span class="math">\(AB \ne BA\)</span>.</p>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p><strong>Định nghĩa 2.2 Ma trận đơn vị</strong></p>
<p>Trong <span class="math">\(\mathbb{R}^{n \times n}\)</span>, ta định nghĩa <strong>ma trận đơn vị</strong></p>
<div class="math">
\[
I_n :=
\begin{bmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}
\in \mathbb{R}^{n \times n},
\tag{2.17}
\]</div>
<p>là ma trận <span class="math">\(n \times n\)</span> có các phần tử trên đường chéo chính bằng 1 và các phần tử còn lại bằng 0.</p></div>
<p>Một số tính chất cơ bản:</p>
<p><strong>Tính kết hợp</strong></p>
<div class="math">
\[
(AB)C = A(BC),
\tag{2.18}
\]</div>
<p><strong>Tính phân phối</strong></p>
<div class="math">
\[
(A + B)C = AC + BC, \qquad A(C + D) = AC + AD,
\tag{2.19}
\]</div>
<p><strong>Nhân với ma trận đơn vị</strong></p>
<div class="math">
\[
I_m A = A I_n = A.
\tag{2.20}
\]</div>
<p>Lưu ý rằng <span class="math">\(I_m \ne I_n\)</span> khi <span class="math">\(m \ne n\)</span>.</p>
<hr>
<h3 id="ma-tran-nghich-ao-va-chuyen-vi">2.2.2 Ma trận nghịch đảo và chuyển vị</h3>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p><strong>Định nghĩa 2.3 Ma trận nghịch đảo</strong></p>
<p>Xét một ma trận vuông <span class="math">\(A \in \mathbb{R}^{n \times n}\)</span>. Nếu tồn tại ma trận <span class="math">\(B \in \mathbb{R}^{n \times n}\)</span> sao cho</p>
<div class="math">
\[
AB = I_n = BA,
\]</div>
<p>thì <span class="math">\(B\)</span> được gọi là <strong>ma trận nghịch đảo</strong> của <span class="math">\(A\)</span> và ký hiệu là <span class="math">\(A^{-1}\)</span>.</p></div>
<p>Không phải mọi ma trận <span class="math">\(A\)</span> đều có nghịch đảo. Nếu <span class="math">\(A^{-1}\)</span> tồn tại thì <span class="math">\(A\)</span> được gọi là <strong>khả nghịch/không suy biến</strong>; ngược lại, <span class="math">\(A\)</span> là <strong>suy biến/không khả nghịch</strong>. Khi tồn tại, nghịch đảo là <strong>duy nhất</strong>.</p>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p><strong>Nhận xét (Tồn tại nghịch đảo của ma trận <span class="math">\(2 \times 2\)</span>).</strong><br>
Xét</p>
<div class="math">
\[
A :=
\begin{bmatrix}
a_{11} &amp; a_{12} \\
a_{21} &amp; a_{22}
\end{bmatrix}
\in \mathbb{R}^{2 \times 2}.
\tag{2.21}
\]</div>
<p>Nếu ta nhân <span class="math">\(A\)</span> với</p>
<div class="math">
\[
A' :=
\begin{bmatrix}
a_{22} &amp; -a_{12} \\
-a_{21} &amp; a_{11}
\end{bmatrix},
\tag{2.22}
\]</div>
<p>ta thu được</p>
<div class="math">
\[
AA' =
\begin{bmatrix}
a_{11}a_{22} - a_{12}a_{21} &amp; 0 \\
0 &amp; a_{11}a_{22} - a_{12}a_{21}
\end{bmatrix}
=
(a_{11}a_{22} - a_{12}a_{21}) I.
\tag{2.23}
\]</div>
<p>Do đó,</p>
<div class="math">
\[
A^{-1} =
\frac{1}{a_{11}a_{22} - a_{12}a_{21}}
\begin{bmatrix}
a_{22} &amp; -a_{12} \\
-a_{21} &amp; a_{11}
\end{bmatrix}
\tag{2.24}
\]</div>
<p><strong>khi và chỉ khi</strong> <span class="math">\(a_{11}a_{22} - a_{12}a_{21} \ne 0\)</span>.</p></div>
<p><strong>Ví dụ 2.4 (Ma trận nghịch đảo)</strong></p>
<p>Hai ma trận</p>
<div class="math">
\[
A =
\begin{bmatrix}
1 &amp; 2 &amp; 1 \\
4 &amp; 4 &amp; 5 \\
6 &amp; 7 &amp; 7
\end{bmatrix},
\qquad
B =
\begin{bmatrix}
-7 &amp; -7 &amp; 6 \\
2 &amp; 1 &amp; -1 \\
4 &amp; 5 &amp; -4
\end{bmatrix}
\tag{2.25}
\]</div>
<p>là nghịch đảo của nhau vì <span class="math">\(AB = I = BA\)</span>.</p>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p><strong>Định nghĩa 2.4 (Chuyển vị)</strong></p>
<p>Với <span class="math">\(A \in \mathbb{R}^{m \times n}\)</span>, ma trận <span class="math">\(B \in \mathbb{R}^{n \times m}\)</span> thỏa <span class="math">\(b_{ij} = a_{ji}\)</span> được gọi là <strong>ma trận chuyển vị</strong> của <span class="math">\(A\)</span>, ký hiệu là <span class="math">\(A^\top\)</span>.</p>
<p>Các tính chất quan trọng:</p>
<div class="math">
\[
AA^{-1} = I = A^{-1}A,
\tag{2.26}
\]</div>
<div class="math">
\[
(AB)^{-1} = B^{-1} A^{-1},
\tag{2.27}
\]</div>
<div class="math">
\[
(A + B)^{-1} \ne A^{-1} + B^{-1},
\tag{2.28}
\]</div>
<div class="math">
\[
(A^\top)^\top = A,
\tag{2.29}
\]</div>
<div class="math">
\[
(AB)^\top = B^\top A^\top,
\tag{2.30}
\]</div>
<div class="math">
\[
(A + B)^\top = A^\top + B^\top.
\tag{2.31}
\]</div></div>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p><strong>Định nghĩa 2.5 (Ma trận đối xứng)</strong></p>
<p>Một ma trận <span class="math">\(A \in \mathbb{R}^{n \times n}\)</span> được gọi là <strong>đối xứng</strong> nếu</p>
<div class="math">
\[
A = A^\top.
\]</div>
<p>Chỉ các ma trận vuông mới có thể là đối xứng. Nếu <span class="math">\(A\)</span> khả nghịch thì <span class="math">\(A^\top\)</span> cũng khả nghịch và</p>
<div class="math">
\[
(A^{-1})^\top = (A^\top)^{-1} = A^{-\top}.
\]</div>
<p><strong>Nhận xét.</strong> Tổng của hai ma trận đối xứng luôn đối xứng, nhưng tích của chúng nói chung <strong>không</strong> đối xứng:</p>
<div class="math">
\[
\begin{bmatrix}
1 &amp; 0 \\
0 &amp; 0
\end{bmatrix}
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 1 \\
0 &amp; 0
\end{bmatrix}.
\tag{2.32}
\]</div></div>
<h3 id="nhan-ma-tran-voi-mot-so-vo-huong">2.2.3 Nhân ma trận với một số vô hướng</h3>
<p>Với <span class="math">\(A \in \mathbb{R}^{m \times n}\)</span> và <span class="math">\(\lambda \in \mathbb{R}\)</span>, ta có <span class="math">\(\lambda A = K\)</span> với <span class="math">\(K_{ij} = \lambda a_{ij}\)</span>. Tức là <span class="math">\(\lambda\)</span> <strong>co giãn</strong> mọi phần tử của <span class="math">\(A\)</span>.</p>
<p>Các tính chất:</p>
<p><strong>Tính kết hợp</strong></p>
<div class="math">
\[
(\lambda \psi) C = \lambda (\psi C),
\]</div>
<div class="math">
\[
\lambda (BC) = (\lambda B)C = B(\lambda C) = (BC)\lambda.
\]</div>
<p><strong>Tính phân phối</strong></p>
<div class="math">
\[
(\lambda + \psi) C = \lambda C + \psi C,
\]</div>
<div class="math">
\[
\lambda (B + C) = \lambda B + \lambda C.
\]</div>
<p><strong>Ví dụ 2.5 (Tính phân phối)</strong></p>
<p>Cho</p>
<div class="math">
\[
C :=
\begin{bmatrix}
1 &amp; 2 \\
3 &amp; 4
\end{bmatrix},
\tag{2.33}
\]</div>
<p>với mọi <span class="math">\(\lambda, \psi \in \mathbb{R}\)</span> ta có</p>
<div class="math">
\[
(\lambda + \psi) C =
\begin{bmatrix}
\lambda + \psi &amp; 2\lambda + 2\psi \\
3\lambda + 3\psi &amp; 4\lambda + 4\psi
\end{bmatrix}
= \lambda C + \psi C.
\tag{2.34}
\]</div>
<h3 id="bieu-dien-gon-cua-he-phuong-trinh-tuyen-tinh">2.2.4 Biểu diễn gọn của hệ phương trình tuyến tính</h3>
<p>Xét hệ</p>
<div class="math">
\[
\begin{aligned}
2x_1 + 3x_2 + 5x_3 &amp;= 1 \\
4x_1 - 2x_2 - 7x_3 &amp;= 8 \\
9x_1 + 5x_2 - 3x_3 &amp;= 2
\end{aligned}
\tag{2.35}
\]</div>
<p>Sử dụng quy tắc nhân ma trận, ta có thể viết gọn hệ này dưới dạng</p>
<div class="math">
\[
\begin{bmatrix}
2 &amp; 3 &amp; 5 \\
4 &amp; -2 &amp; -7 \\
9 &amp; 5 &amp; -3
\end{bmatrix}
\begin{bmatrix}
x_1 \\
x_2 \\
x_3
\end{bmatrix}
=
\begin{bmatrix}
1 \\
8 \\
2
\end{bmatrix}.
\tag{2.36}
\]</div>
<p>Nói chung, một hệ phương trình tuyến tính có thể được biểu diễn gọn dưới dạng <strong><span class="math">\(Ax = b\)</span></strong>, và tích <span class="math">\(Ax\)</span> là một tổ hợp tuyến tính của các cột của <span class="math">\(A\)</span>. Chúng ta sẽ thảo luận chi tiết hơn về tổ hợp tuyến tính trong Mục 2.5.</p>
<h2 id="giai-he-phuong-trinh-tuyen-tinh">2.3 Giải hệ phương trình tuyến tính</h2>
<p>Trong (2.3), chúng ta đã giới thiệu dạng tổng quát của một hệ phương trình, tức là</p>
<div class="math">
\[
\begin{aligned}
a_{11}x_1 + \cdots + a_{1n}x_n &amp;= b_1 \\
\vdots &amp; \vdots \\
a_{m1}x_1 + \cdots + a_{mn}x_n &amp;= b_m
\end{aligned}
\tag{2.37}
\]</div>
<p>trong đó <span class="math">\(a_{ij} \in \mathbb{R}\)</span> và <span class="math">\(b_i \in \mathbb{R}\)</span> là các hằng số đã biết, còn <span class="math">\(x_j\)</span> là các ẩn số,
với <span class="math">\(i = 1,\ldots,m\)</span>, <span class="math">\(j = 1,\ldots,n\)</span>.</p>
<p>Cho đến nay, chúng ta đã thấy rằng ma trận có thể được dùng như một cách gọn gàng để biểu diễn các hệ phương trình tuyến tính, sao cho ta có thể viết</p>
<div class="math">
\[
Ax = b
\tag{2.10}
\]</div>
<h3 id="nghiem-rieng-va-nghiem-tong-quat">2.3.1 Nghiệm riêng và nghiệm tổng quát</h3>
<p>Xét hệ phương trình</p>
<div class="math">
\[
\begin{bmatrix}
1 &amp; 0 &amp; 8 &amp; -4 \\
0 &amp; 1 &amp; 2 &amp; 12
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2 \\ x_3 \\ x_4
\end{bmatrix}
=
\begin{bmatrix}
42 \\ 8
\end{bmatrix}
\tag{2.38}
\]</div>
<p>Một nghiệm của hệ là</p>
<div class="math">
\[
x =
\begin{bmatrix}
42 \\ 8 \\ 0 \\ 0
\end{bmatrix}
\]</div>
<p>Nghiệm này được gọi là <strong>nghiệm riêng</strong> (hay <strong>nghiệm đặc biệt</strong>).</p>
<h3 id="dang-bac-thang-theo-hang-row-echelon-form">2.3.2 Dạng bậc thang theo hàng (Row-Echelon Form)</h3>
<p>Một ma trận được gọi là ở <strong>dạng bậc thang theo hàng (REF)</strong> nếu:</p>
<ol><li>Tất cả các hàng chỉ gồm số 0 nằm ở cuối ma trận.</li>
<li>Hệ số khác 0 đầu tiên (pivot) của mỗi hàng nằm <strong>bên phải</strong> pivot của hàng phía trên.</li></ol>
<h3 id="dang-bac-thang-rut-gon-theo-hang-reduced-row-echelon-form">2.3.3 Dạng bậc thang rút gọn theo hàng (Reduced Row-Echelon Form)</h3>
<div class="alert alert-info" role="alert"><div class="d-flex align-items-center"><i class="bi-info-circle-fill flex-shrink-0 me-2" aria-label="Info:"></i>
<h5>Info:</h5></div>
<p>Một ma trận ở <strong>dạng bậc thang rút gọn theo hàng (RREF)</strong> nếu:</p>
<ol><li>Nó đã ở dạng REF.</li>
<li>Mỗi pivot bằng 1.</li>
<li>Pivot là phần tử khác 0 duy nhất trong cột của nó.</li></ol></div>
<p><strong>Ví dụ (Dạng bậc thang rút gọn theo hàng)</strong></p>
<div class="math">
\[
A =
\begin{bmatrix}
1 &amp; 3 &amp; 0 &amp; 0 &amp; 3 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; -4
\end{bmatrix}
\tag{2.49}
\]</div>
<h3 id="nghiem-tong-quat-cua-he-thuan-nhat">2.3.4 Nghiệm tổng quát của hệ thuần nhất</h3>
<p>Mọi nghiệm của hệ <span class="math">\(Ax = 0\)</span>, với <span class="math">\(x \in \mathbb{R}^5\)</span>, được cho bởi</p>
<div class="math">
\[
\left\{
x = \lambda_1
\begin{bmatrix}
3 \\ -1 \\ 0 \\ 0 \\ 0
\end{bmatrix}
+
\lambda_2
\begin{bmatrix}
3 \\ 0 \\ 9 \\ -4 \\ -1
\end{bmatrix}
\;\middle|\;
\lambda_1, \lambda_2 \in \mathbb{R}
\right\}
\tag{2.50}
\]</div>
<p><strong>Mẹo &quot;Minus-1&quot;</strong></p>
<p>Trong phần này, chúng ta giới thiệu một <strong>mẹo thực hành</strong> để đọc ra nghiệm <span class="math">\(x\)</span> của một <strong>hệ phương trình tuyến tính thuần nhất</strong></p>
<div class="math">
\[
Ax = 0,
\]</div>
<p>trong đó <span class="math">\(A \in \mathbb{R}^{k \times n}\)</span> và <span class="math">\(x \in \mathbb{R}^n\)</span>.</p>
<p>Trước hết, ta giả sử rằng <span class="math">\(A\)</span> đang ở <strong>dạng bậc thang rút gọn theo hàng</strong> (reduced row-echelon form – RREF) và <strong>không có hàng nào toàn số 0</strong>, tức là</p>
<div class="math">
\[
A =
\begin{bmatrix}
0 &amp; \cdots &amp; 0 &amp; 1 &amp; * &amp; \cdots &amp; * &amp; 0 &amp; * &amp; \cdots &amp; * &amp; 0 &amp; * &amp; \cdots &amp; * \\
\vdots &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\
0 &amp; \cdots &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1 &amp; * &amp; \cdots &amp; * \\
\vdots &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\
0 &amp; \cdots &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1 &amp; * &amp; \cdots &amp; *
\end{bmatrix},
\tag{2.51}
\]</div>
<p>trong đó <span class="math">\(*\)</span> là các số thực bất kỳ, với các ràng buộc sau:</p>
<ul><li>Phần tử khác 0 đầu tiên trong mỗi hàng phải bằng 1 (pivot).</li>
<li>Mọi phần tử khác trong cột chứa pivot đều bằng 0.</li></ul>
<p>Các cột <span class="math">\(j_1,\ldots,j_k\)</span> chứa các pivot (được đánh dấu đậm trong sách) chính là các <strong>vector đơn vị chuẩn</strong></p>
<div class="math">
\[
e_1,\ldots,e_k \in \mathbb{R}^k.
\]</div>
<p>Tiếp theo, ta <strong>mở rộng ma trận này thành một ma trận vuông <span class="math">\(n \times n\)</span></strong>, ký hiệu là <span class="math">\(\tilde{A}\)</span>, bằng cách thêm <span class="math">\(n-k\)</span> hàng có dạng</p>
<div class="math">
\[
[\,0 \;\cdots\; 0 \; -1 \; 0 \;\cdots\; 0\,]
\tag{2.52}
\]</div>
<p>sao cho <strong>đường chéo chính của ma trận mở rộng <span class="math">\(\tilde{A}\)</span> chỉ chứa 1 hoặc −1</strong>.</p>
<p>Khi đó, <strong>các cột của <span class="math">\(\tilde{A}\)</span> có −1 nằm trên đường chéo chính chính là các nghiệm của hệ thuần nhất</strong></p>
<div class="math">
\[
Ax = 0.
\]</div>
<p>Chính xác hơn, các cột này tạo thành <strong>một cơ sở</strong> (xem Mục 2.6.1) của <strong>không gian nghiệm</strong> của <span class="math">\(Ax = 0\)</span>, không gian này về sau sẽ được gọi là <strong>kernel</strong> hay <strong>null space</strong> (xem Mục 2.7.3).</p>
<p><strong>Ví dụ 2.8 (Mẹo Minus-1)</strong></p>
<p>Xét lại ma trận trong (2.49), vốn đã ở dạng RREF:</p>
<div class="math">
\[
A =
\begin{bmatrix}
1 &amp; 3 &amp; 0 &amp; 0 &amp; 3 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; -4
\end{bmatrix}.
\tag{2.53}
\]</div>
<p>Ta mở rộng ma trận này thành ma trận <span class="math">\(5 \times 5\)</span> bằng cách thêm các hàng dạng (2.52) tại những vị trí mà đường chéo chính chưa có pivot, và thu được</p>
<div class="math">
\[
\tilde{A} =
\begin{bmatrix}
1 &amp; 3 &amp; 0 &amp; 0 &amp; 3 \\
0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; -4 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; -1
\end{bmatrix}.
\tag{2.54}
\]</div>
<p>Từ dạng này, ta <strong>có thể đọc ngay nghiệm của <span class="math">\(Ax = 0\)</span></strong> bằng cách lấy các cột của <span class="math">\(\tilde{A}\)</span> có phần tử −1 trên đường chéo chính:</p>
<div class="math">
\[
\left\{
x \in \mathbb{R}^5 :
x =
\lambda_1
\begin{bmatrix}
3 \\ -1 \\ 0 \\ 0 \\ 0
\end{bmatrix}
+
\lambda_2
\begin{bmatrix}
3 \\ 0 \\ 9 \\ -4 \\ -1
\end{bmatrix},
\;
\lambda_1,\lambda_2 \in \mathbb{R}
\right\}
\tag{2.55}
\]</div>
<p>Kết quả này <strong>hoàn toàn trùng với nghiệm trong (2.50)</strong> mà trước đó ta thu được bằng &quot;trực giác&quot;.</p>
<h3 id="tinh-ma-tran-nghich-ao">2.3.5 Tính ma trận nghịch đảo</h3>
<p>Để tính ma trận nghịch đảo <span class="math">\(A^{-1}\)</span> của <span class="math">\(A \in \mathbb{R}^{n \times n}\)</span>, ta cần tìm một ma trận <span class="math">\(X\)</span> sao cho</p>
<div class="math">
\[
AX = I_n.
\]</div>
<p>Khi đó <span class="math">\(X = A^{-1}\)</span>. Ta có thể xem đây là một hệ phương trình tuyến tính đồng thời</p>
<div class="math">
\[
AX = I_n,
\]</div>
<p>trong đó</p>
<div class="math">
\[
X = [x_1 \mid \cdots \mid x_n].
\]</div>
<p>Sử dụng ký hiệu <strong>ma trận mở rộng</strong>, ta có</p>
<div class="math">
\[
\left[ A \mid I_n \right]
\;\Longrightarrow\;
\left[ I_n \mid A^{-1} \right].
\tag{2.56}
\]</div>
<p>Điều này có nghĩa là: <strong>nếu đưa hệ phương trình mở rộng về dạng bậc thang rút gọn theo hàng, ta có thể đọc ra trực tiếp ma trận nghịch đảo ở vế phải</strong>. Do đó, việc tìm ma trận nghịch đảo tương đương với việc giải các hệ phương trình tuyến tính.</p></div></article></main><aside class="toc-sidebar toc-desktop" b-qjr5eoji3o><div class="toc-wrapper"><h4 class="toc-title">Mục lục</h4></div></aside><div class="toc-mobile-overlay " b-qjr5eoji3o></div>
                <aside class="toc-mobile-drawer " b-qjr5eoji3o><div class="toc-mobile-header" b-qjr5eoji3o><h4 b-qjr5eoji3o>Mục lục</h4>
                        <button class="toc-close-btn" title="&#x110;&#xF3;ng" b-qjr5eoji3o><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" b-qjr5eoji3o><line x1="18" y1="6" x2="6" y2="18" b-qjr5eoji3o></line>
                                <line x1="6" y1="6" x2="18" y2="18" b-qjr5eoji3o></line></svg></button></div>
                    <div class="toc-mobile-content" b-qjr5eoji3o><div class="toc-wrapper"><h4 class="toc-title">Mục lục</h4></div></div></aside><button class="toc-fab " title="M&#x1EE5;c l&#x1EE5;c" b-qjr5eoji3o><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" b-qjr5eoji3o><line x1="3" y1="6" x2="21" y2="6" b-qjr5eoji3o></line>
                        <line x1="3" y1="12" x2="15" y2="12" b-qjr5eoji3o></line>
                        <line x1="3" y1="18" x2="18" y2="18" b-qjr5eoji3o></line></svg></button></div><footer class="home-footer site-footer" b-qjr5eoji3o><div class="footer-inner" b-qjr5eoji3o><div class="footer-left" b-qjr5eoji3o><p b-qjr5eoji3o>&#xA9; 2026 Code Magic. All rights reserved.</p></div>
            <div class="footer-right" b-qjr5eoji3o><nav class="footer-nav" aria-label="Footer" b-qjr5eoji3o><a href="about" b-qjr5eoji3o>Giới thiệu</a>
                    <span class="dot" b-qjr5eoji3o>·</span>
                    <a href="sitemap" b-qjr5eoji3o>Sitemap</a>
                    <span class="dot" b-qjr5eoji3o>·</span>
                    <a href="https://github.com/chicuong2k3" target="_blank" rel="noopener" b-qjr5eoji3o>GitHub</a></nav></div></div></footer>

    <div class="search-container "><div class="search-overlay"></div>
    <div class="search-modal"><div class="search-header"><svg class="search-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path></svg>
            <input value="" class="search-input" placeholder="T&#xEC;m ch&#x1B0;&#x1A1;ng, s&#xE1;ch..." />
            <div class="search-kbd"><kbd>ESC</kbd></div>
            <button class="search-close"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"></path></svg></button></div>

        <div class="search-body"><div class="search-suggestions"><div class="suggestions-label">Sách phổ biến</div>
                    <div class="tag-suggestions"><a href="book/mathematics-for-machine-learning" class="tag-suggestion">MATHEMATICS FOR MACHINE LEARNING</a><a href="book/on-the-composition-of-images,-signs-&amp;-ideas" class="tag-suggestion">ON THE COMPOSITION OF IMAGES, SIGNS &amp; IDEAS</a></div></div></div>

        <div class="search-footer"><div class="search-tips"><span><kbd>Enter</kbd> để tìm</span>
                <span><kbd>ESC</kbd> để thoát</span></div></div></div></div></div>
        <blazor-focus-on-navigate selector="h1"></blazor-focus-on-navigate>
<!-- %%-PRERENDERING-END-%% -->
</div>

    <!-- Browser compatibility warning for iOS < 15 -->
    <div id="browser-compat-warning" style="display:none; position:fixed; bottom:0; left:0; right:0; z-index:9998; padding:12px 16px; background:linear-gradient(135deg, #fef3c7, #fde68a); border-top:2px solid #f59e0b; color:#92400e; font-size:14px; text-align:center;">
        <span style="display:flex; align-items:center; justify-content:center; gap:8px; flex-wrap:wrap;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            <span>Trình duyệt của bạn có thể không hỗ trợ đầy đủ. Vui lòng cập nhật lên iOS 15+ hoặc Safari 15+ để có trải nghiệm tốt nhất.</span>
            <button onclick="this.parentElement.parentElement.style.display='none'" style="background:#92400e; color:white; border:none; padding:4px 12px; border-radius:4px; cursor:pointer; margin-left:8px;">Đóng</button>
        </span>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="." class="reload">Reload</a>
        <span class="dismiss">🗙</span>
    </div>

    <script type="text/javascript">
        // MathJax configuration - adjust delimiters as needed
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>

    <script type="text/javascript" id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
        </script>

    <!-- Polyfills + Mermaid dual-loader (module + nomodule fallback) -->
    <script>
        // Polyfills for older Safari (Element.matches / Element.closest)
        if (!Element.prototype.matches) {
            Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
                var matches = (this.document || this.ownerDocument).querySelectorAll(s), i = matches.length;
                while (--i >= 0 && matches.item(i) !== this) { }
                return i > -1;
            };
        }
        if (!Element.prototype.closest) {
            Element.prototype.closest = function (s) {
                var el = this;
                do {
                    if (el.matches && el.matches(s)) return el;
                    el = el.parentElement || el.parentNode;
                } while (el !== null && el.nodeType === 1);
                return null;
            };
        }

        // Mermaid (ES module) for modern browsers
    </script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        // Keep configuration minimal and safe for older engines
        mermaid.initialize({ startOnLoad: false, theme: 'dark' });

        window._mermaid = mermaid;
        window.renderMermaid = async function (srcId, containerId) {
            const srcEl = document.getElementById(srcId);
            const containerEl = document.getElementById(containerId);
            if (!srcEl || !containerEl) return;

            // Use textContent for maximum compatibility
            const definition = srcEl.textContent.trim();
            if (!definition) return;

            try {
                // mermaid.render may return { svg } or a string depending on build
                const maybe = await mermaid.render('mermaid-' + Date.now(), definition);
                if (maybe && maybe.svg) containerEl.innerHTML = maybe.svg;
                else if (typeof maybe === 'string') containerEl.innerHTML = maybe;
                else {
                    containerEl.innerHTML = '<pre style="color:red;">Mermaid: unexpected render result</pre>';
                    if (window.isOldSafari && window.isOldSafari()) window.showBrowserError('Mermaid unexpected render result', String(maybe));
                }
            } catch (e) {
                containerEl.innerHTML = '<pre style="color:red;">Mermaid Error: ' + (e && e.message || e) + '</pre>';
                if (window.isOldSafari && window.isOldSafari()) window.showBrowserError('Mermaid render failed', e && e.message ? e.message : String(e));
            }
        };
    </script>

    <!-- UMD/nombre module fallback for older Safari that doesn't fully support modules -->
    <script nomodule="" src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
    <script nomodule="">
        if (window.mermaid) {
            window._mermaid = window.mermaid;
            window._mermaid.initialize({ startOnLoad: false, theme: 'dark' });

            window.renderMermaid = function (srcId, containerId) {
                const srcEl = document.getElementById(srcId);
                const containerEl = document.getElementById(containerId);
                if (!srcEl || !containerEl) return;
                const definition = srcEl.textContent.trim();
                if (!definition) return;

                try {
                    // Some UMD builds return svg string or { svg }, others use callback
                    try {
                        const result = window._mermaid.render('mermaid-' + Date.now(), definition);
                        if (result && result.svg) containerEl.innerHTML = result.svg;
                        else if (typeof result === 'string') containerEl.innerHTML = result;
                        else {
                            containerEl.innerHTML = '<pre style="color:red;">Mermaid: unexpected render result</pre>';
                            if (window.isOldSafari && window.isOldSafari()) window.showBrowserError('Mermaid unexpected render result', String(result));
                        }
                    } catch (err) {
                        // Try callback signature
                        window._mermaid.render('mermaid-' + Date.now(), definition, function (svgCode) {
                            containerEl.innerHTML = svgCode;
                        });
                    }
                } catch (e) {
                    containerEl.innerHTML = '<pre style="color:red;">Mermaid Error: ' + (e && e.message || e) + '</pre>';
                    if (window.isOldSafari && window.isOldSafari()) window.showBrowserError('Mermaid render failed', e && e.message ? e.message : String(e));
                }
            };
        }
    </script>

    <script src="_framework/blazor.webassembly.66stpp682q.js"></script>

    <script>
        // Small helper: detect old Safari / iOS (<=15)
        window.isOldSafari = function () {
            try {
                var ua = navigator.userAgent || '';
                // iOS Safari detection: look for 'OS 12_...' or similar
                var iosMatch = ua.match(/OS (\d+)_/i);
                if (iosMatch && iosMatch[1]) {
                    var iosVer = parseInt(iosMatch[1], 10);
                    return iosVer <= 15;
                }

                // Desktop Safari: contains 'Safari' and 'Version/X' and not Chrome/Chromium/Edge
                if (/Safari/.test(ua) && !/Chrome|Chromium|CrMo|CriOS|Edg|OPR|Android/.test(ua)) {
                    var verMatch = ua.match(/Version\/(\d+)\./i);
                    if (verMatch && verMatch[1]) {
                        var ver = parseInt(verMatch[1], 10);
                        return ver <= 15;
                    }
                }
            } catch (e) {
                console.warn('isOldSafari detection failed', e);
            }
            return false;
        };

        // Display a friendly error UI for browser-caused problems (visible on the page)
        window.showBrowserError = function (message, details) {
            try {
                var el = document.getElementById('blazor-error-ui');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'blazor-error-ui';
                    document.body.appendChild(el);
                }

                // Basic styling so it's visible even if site styles hide it
                el.style.display = 'block';
                el.style.position = 'fixed';
                el.style.left = '8px';
                el.style.right = '8px';
                el.style.bottom = '8px';
                el.style.zIndex = 99999;
                el.style.background = '#fff6f6';
                el.style.border = '1px solid #f5c2c2';
                el.style.color = '#661414';
                el.style.padding = '12px';
                el.style.borderRadius = '8px';
                el.style.boxShadow = '0 6px 18px rgba(0,0,0,0.08)';
                el.style.maxHeight = '40vh';
                el.style.overflow = 'auto';

                var uaNote = window.isOldSafari && window.isOldSafari() ? '<div style="font-size:12px;color:#8a0000;margin-bottom:8px">Warning: Browser looks like an older Safari/iOS — some features may not work correctly.</div>' : '';

                var detailsHtml = details ? ('<pre style="white-space:pre-wrap;margin:6px 0;padding:8px;background:#fff;border-radius:6px;border:1px solid #fee;max-height:200px;overflow:auto;">' + escapeHtml(details) + '</pre>') : '';

                el.innerHTML = '<strong>Browser error detected</strong>' + uaNote + '<div style="margin-top:6px;word-break:break-word;">' + escapeHtml(message || 'Unknown browser error') + '</div>' + detailsHtml + '<div style="margin-top:8px;text-align:right;"><button id="blazor-error-dismiss" style="background:#fff;color:#661414;border:1px solid #f5c2c2;padding:6px 10px;border-radius:6px;cursor:pointer">Dismiss</button></div>';

                var btn = document.getElementById('blazor-error-dismiss');
                if (btn) btn.addEventListener('click', function () { el.style.display = 'none'; });

                // helper to escape HTML to avoid breaking page
                function escapeHtml(str) {
                    if (!str) return '';
                    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                }

                // Also log to console for diagnostics
                console.error('Browser error shown to user:', message, details);
            } catch (e) {
                console.error('showBrowserError failed', e);
            }
        };

        // Show compatibility warning for old Safari/iOS on page load
        (function() {
            try {
                if (window.isOldSafari && window.isOldSafari()) {
                    var warning = document.getElementById('browser-compat-warning');
                    if (warning) {
                        warning.style.display = 'block';
                    }
                }
            } catch (e) {
                // ignore
            }
        })();

        // Global handlers: only surface UI error if we're on older Safari (user requested)
        window.addEventListener('error', function (evt) {
            try {
                if (window.isOldSafari && window.isOldSafari()) {
                    var details = (evt.filename ? evt.filename + ':' + evt.lineno + ':' + evt.colno + '\n' : '') + (evt.error && evt.error.stack ? evt.error.stack : '');
                    window.showBrowserError(evt.message || 'Script error', details);
                }
            } catch (e) {
                // ignore
            }
        });

        window.addEventListener('unhandledrejection', function (evt) {
            try {
                if (window.isOldSafari && window.isOldSafari()) {
                    var reason = evt.reason && (evt.reason.message || evt.reason) ? (evt.reason.message || String(evt.reason)) : 'Unhandled rejection';
                    var stack = evt.reason && evt.reason.stack ? evt.reason.stack : '';
                    window.showBrowserError('Unhandled promise rejection: ' + reason, stack);
                }
            } catch (e) {
                // ignore
            }
        });

        // Smooth scroll to heading
        window.scrollToHeading = function (id) {
            const element = document.getElementById(id);
            if (element) {
                const headerOffset = 100;
                const elementPosition = element.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
            }
        };

        // Table of Contents functionality
        window.initToc = function (dotNetRef) {
            let currentObserver = null;
            let scrollHandler = null;

            const updateToc = () => {
                const content = document.querySelector('.content');
                if (!content) return;

                const headings = content.querySelectorAll('h1, h2, h3');
                const items = [];

                headings.forEach((heading, index) => {
                    // Ensure heading has an ID
                    if (!heading.id) {
                        heading.id = 'heading-' + index;
                    }
                    items.push({
                        id: heading.id,
                        text: heading.textContent.trim(),
                        level: parseInt(heading.tagName.charAt(1))
                    });
                });

                dotNetRef.invokeMethodAsync('UpdateTocItems', items);
            };

            // Initial update
            setTimeout(updateToc, 100);

            // Update on navigation/content changes
            currentObserver = new MutationObserver(() => {
                setTimeout(updateToc, 100);
            });
            currentObserver.observe(document.body, { childList: true, subtree: true });

            // Track active heading on scroll with improved detection
            let ticking = false;
            scrollHandler = () => {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        const headings = document.querySelectorAll('.content h1, .content h2, .content h3');
                        let activeId = null;
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        const viewportHeight = window.innerHeight;

                        // Find the heading that's currently in view
                        for (const heading of headings) {
                            const rect = heading.getBoundingClientRect();
                            const headingTop = rect.top + scrollTop;

                            // Consider a heading active if it's within the top portion of viewport
                            if (rect.top <= 150) {
                                activeId = heading.id;
                            }
                        }

                        // If at the very top, select first heading
                        if (scrollTop < 100 && headings.length > 0) {
                            activeId = headings[0].id;
                        }

                        // If at the very bottom, select last heading
                        if ((window.innerHeight + scrollTop) >= document.body.offsetHeight - 50) {
                            if (headings.length > 0) {
                                activeId = headings[headings.length - 1].id;
                            }
                        }

                        if (activeId) {
                            dotNetRef.invokeMethodAsync('SetActiveHeading', activeId);
                        }
                        ticking = false;
                    });
                    ticking = true;
                }
            };

            window.addEventListener('scroll', scrollHandler, { passive: true });

            // Trigger initial scroll check
            setTimeout(scrollHandler, 200);
        };

        // Copy code to clipboard (with execCommand fallback for older Safari)
        window.copyCode = async function (button) {
            if (!button) return;
            const codeBlock = button.closest && button.closest('.code-block');
            if (!codeBlock) return;
            const codeEl = codeBlock.querySelector('code');
            const text = codeEl ? (codeEl.textContent || codeEl.innerText || '') : '';
            if (!text) return;

            // Try navigator.clipboard first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                try {
                    await navigator.clipboard.writeText(text);
                    showCopied(button);
                    return;
                } catch (e) {
                    // fall through to fallback
                    if (window.isOldSafari && window.isOldSafari()) window.showBrowserError('Clipboard API failed', e && e.message ? e.message : String(e));
                }
            }

            // Fallback using textarea + execCommand
            try {
                const ta = document.createElement('textarea');
                ta.value = text;
                // Make element readonly to avoid iOS virtual keyboard
                ta.setAttribute('readonly', '');
                ta.style.position = 'absolute';
                ta.style.left = '-9999px';
                // For iOS selection support
                document.body.appendChild(ta);

                const range = document.createRange();
                range.selectNodeContents(ta);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
                ta.select();

                const successful = document.execCommand('copy');
                document.body.removeChild(ta);

                if (successful) {
                    showCopied(button);
                } else {
                    throw new Error('execCommand failed');
                }
            } catch (err) {
                console.error('Failed to copy:', err);
                if (window.isOldSafari && window.isOldSafari()) window.showBrowserError('Copy to clipboard failed', err && err.message ? err.message : String(err));
            }

            function showCopied(btn) {
                if (!btn) return;
                btn.classList.add('copied');
                const prev = btn.innerHTML;
                btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
                setTimeout(() => {
                    btn.classList.remove('copied');
                    btn.innerHTML = prev;
                }, 2000);
            }
        };

        // Initialize code blocks with copy button and syntax highlighting
        window.initCodeBlocks = function () {
            document.querySelectorAll('pre:not(.code-initialized)').forEach(pre => {
                // Skip mermaid and special pre blocks
                if (pre.closest('.mermaid-container') || pre.style.display === 'none') return;

                pre.classList.add('code-initialized');

                // Wrap in code-block container
                const wrapper = document.createElement('div');
                wrapper.className = 'code-block';

                // Get language from code element class
                const code = pre.querySelector('code');
                let language = 'text';
                if (code) {
                    const langClass = Array.from(code.classList).find(c => c.startsWith('language-'));
                    if (langClass) {
                        language = langClass.replace('language-', '');
                    }
                }

                // Create header with language label and copy button
                const header = document.createElement('div');
                header.className = 'code-header';
                header.innerHTML = `
                    <span class="code-lang">${language}</span>
                    <button class="copy-btn" onclick="copyCode(this)">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                        </svg>
                        Copy
                    </button>
                `;

                pre.parentNode.insertBefore(wrapper, pre);
                wrapper.appendChild(header);
                wrapper.appendChild(pre);
            });

            // Apply Prism highlighting
            if (window.Prism) {
                Prism.highlightAll();
            }
        };

        // Run on page load and after Blazor navigation
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initCodeBlocks, 500);
        });

        // Observe DOM changes for Blazor navigation
        const codeObserver = new MutationObserver(() => {
            setTimeout(initCodeBlocks, 100);
        });
        codeObserver.observe(document.body, { childList: true, subtree: true });

        // Load chapter content for printing via iframe
        window.loadChapterContent = function (url) {
            return new Promise((resolve, reject) => {
                const iframe = document.getElementById('content-loader');
                if (!iframe) {
                    // Create iframe if not exists
                    const newIframe = document.createElement('iframe');
                    newIframe.id = 'content-loader';
                    newIframe.style.cssText = 'display:none; position:absolute; left:-9999px; width:1024px; height:768px;';
                    document.body.appendChild(newIframe);
                }

                const loader = document.getElementById('content-loader');
                let timeoutId = null;
                let checkInterval = null;

                const cleanup = () => {
                    if (timeoutId) clearTimeout(timeoutId);
                    if (checkInterval) clearInterval(checkInterval);
                    loader.onload = null;
                    loader.onerror = null;
                };

                loader.onload = () => {
                    // Wait for Blazor to render content
                    let attempts = 0;
                    const maxAttempts = 50; // 5 seconds max

                    checkInterval = setInterval(() => {
                        attempts++;
                        try {
                            const iframeDoc = loader.contentDocument || loader.contentWindow.document;
                            const content = iframeDoc.querySelector('.content');

                            if (content && content.innerHTML.trim().length > 100) {
                                cleanup();
                                // Clone and clean content
                                let html = content.innerHTML;
                                // Remove navigation elements that might be inside content
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = html;
                                // Remove any nested scripts
                                tempDiv.querySelectorAll('script').forEach(s => s.remove());
                                // Remove chapter navigation
                                tempDiv.querySelectorAll('.chapter-navigation, .ChapterNavigation').forEach(n => n.remove());
                                resolve(tempDiv.innerHTML);
                            } else if (attempts >= maxAttempts) {
                                cleanup();
                                resolve('<p>Timeout loading content.</p>');
                            }
                        } catch (e) {
                            if (attempts >= maxAttempts) {
                                cleanup();
                                reject(e);
                            }
                        }
                    }, 100);
                };

                loader.onerror = (e) => {
                    cleanup();
                    reject(new Error('Failed to load iframe'));
                };

                // Overall timeout
                timeoutId = setTimeout(() => {
                    cleanup();
                    resolve('<p>Timeout loading content.</p>');
                }, 10000);

                loader.src = url;
            });
        };

        // Helper to typeset MathJax for dynamically injected print content
        window.printbookTypeset = function () {
            try {
                if (window.MathJax && typeof MathJax.typesetPromise === 'function') {
                    return MathJax.typesetPromise();
                }
            } catch (e) {
                console.warn('printbookTypeset failed', e);
            }
            return Promise.resolve();
        };
    </script>

    <!-- Prism.js -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-csharp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markup.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-razor.min.js"></script>


</body></html>